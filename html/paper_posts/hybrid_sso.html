<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="A paper post from Tom Wagg" />
        <meta name="author" content="Tom Wagg" />
        <title>Hybrid Solar System Catalogue</title>
        <link href="../../img/icon.png" rel="icon" />
        <!-- Bootstrap -->
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
            rel="stylesheet"
            integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
            crossorigin="anonymous" />
        <!-- icons and fonts -->
        <script src="https://kit.fontawesome.com/328d20ce71.js" crossorigin="anonymous"></script>
        <link rel="preconnect" href="https://fonts.gstatic.com" />
        <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;700;900&display=swap" rel="stylesheet" />
        <!-- random css -->
        <link href="../../css/animate.css" rel="stylesheet" />
        <link href="../../css/blog_style.css" rel="stylesheet" />
        <link href="../../css/dark_mode.css" rel="stylesheet" />

        <!-- Bootstrap core JavaScript -->
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script
            src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
            crossorigin="anonymous"></script>
        <!-- Plugin JavaScript -->
        <script src="../../js/jquery.easing.min.js"></script>
        <!-- Custom scripts for this template -->
        <script src="../../js/blog_style.js"></script>
        <script src="../../js/dark_mode.js"></script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
                       MathJax.Hub.Config({
                           "HTML-CSS": { linebreaks: { automatic: true } },
                                   SVG: { linebreaks: { automatic: true } }
                           });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" async></script>
    </head>

    <body style="position: relative" data-bs-spy="scroll" data-bs-target="#nav" data-bs-offset="0" tabindex="0">
        <div class="back-button">
            <button id="home" class="btn btn-outline-main rounded-circle">
                <i class="fa fa-arrow-left"></i>
            </button>
        </div>
        <!-- I copied this from https://animate.style/ -->
        <label for="dark-mode-checkbox" class="dark-mode-label">
            <input type="checkbox" id="dark-mode-checkbox" />
            <span class="dark-mode-ball"></span>
            <svg viewBox="0 0 512 512" class="sun-svg">
                <path
                    id="sun-svg"
                    d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"></path>
            </svg>
            <svg viewBox="0 0 512 512" class="moon-svg">
                <path
                    id="moon-svg"
                    d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"></path>
            </svg>
        </label>
        <div class="header" style="background-image: url('../../img/hybrid_sso_catalogue/asteroid_belt.jpg">
            <div class="source">
                Image Source:
                <a class="link-light" href="https://www.wired.com/wp-content/uploads/2022/06/Asteroid-Belt-Up-Against-It-Culture-460713865.jpg">SCIEPRO - Wired.com</a>
            </div>
        </div>
        <div class="progress-header">
            <div class="progress-container">
                <div class="progress-bar" id="myBar"></div>
            </div>
        </div>
        <nav id="nav" class="nav nav-pills flex-column toc float-md-end sticky-md-top p-3 pt-4 text-md-end text-center">
            <a class="nav-link" href="#">Top</a>
            <hr class="dropdown-divider" />
            <li class="nav-item dropdown">
                <a class="nav-link" href="#intro" role="button" aria-expanded="false">What's the problem?</a>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" data-bs-toggle="dropdown" href="#sims" role="button" aria-expanded="false">Simulating NEO Follow-up</a>
                <ul class="dropdown-menu dropdown-menu-end">
                    <li><a class="nav-link" href="#traffic_purity">Impact with current criteria</a></li>
                    <li><a class="nav-link" href="#best_case">Best case scenario</a></li>
                </ul>
            </li>
        </nav>
        <div class="container">
            <div class="row">
                <div class="col text-center">
                    <h1 class="fw-bold mb-0">Hybrid Solar System Catalogue Creator</h1>
                    <h2 class="fst-italic mb-3" style="margin-top: -1rem">How can we account for prior detections in our predictions?</h2>
                    <p class="text-center">
                        <a href="" target="_blank" class="btn bg-transparent rounded project-link">
                            <i class="fas fa-scroll fa-2x" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Paper"></i>
                        </a>
                        <a href="https://github.com/dirac-institute/hybrid_sso_catalogue" target="_blank" class="btn bg-transparent rounded project-link">
                            <i class="fab fa-github fa-2x" data-bs-toggle="tooltip" data-bs-placement="bottom" title="GitHub Repo"></i>
                        </a>
                    </p>
                </div>
            </div>
            <div class="row">
                <div class="col">
                    <p class="fs-4">
                        Most current predictions for the Rubin Observatory's Legacy Survey of Space and Time use fully synthetic solar system catalogues. These do not account for the fact that we've
                        already detected <i>a lot</i> of objects in the solar system. This could have some pretty important consequences - let's talk about!
                    </p>

                    <h2 id="intro">What's the problem?</h2>

                    <figure>
                        <div class="img-fluid-limited float-end position-relative ms-2">
                            <img src="../../img/hybrid_sso_catalogue/gru_explains_hybrid_catalogue.png" class="img-fluid" style="border-radius: 2rem" />
                        </div>
                    </figure>
                    <p>
                        I often think that the problem with using fully synthetic catalogues is best explained by Gru (see right). As our favourite supervillain puts it, in rather extreme terms, using
                        a fully synthetic solar system catalogue for making simulations can mean that your predictions include objects that we have known for decades.
                    </p>
                    <p>
                        In reality we of course would not <i>actually</i> predict the re-discovery of Ceres, but we <i>would</i> predict the discovery of a subpopulation of large/bright objects that
                        have actually already been found in the solar system. This not only skews predictions but could also have more pragmatic consequences that we are overestimating the rate at
                        which LSST will detect new objects.
                    </p>
                    <p>Ideally, what we need is a full catalogue of solar system objects that has a flag for each object for whether it has already been detected. Enter: the hybrid catalogue!</p>

                    <h2 id="methods">Combining real and simulated catalogues</h2>
                    <p>
                        The hybrid catalogue solves this problem by combining a simulated catalogue with real data. The simulated catalogue that we use is the Synthetic Solar System Model, more
                        commonly referred to as S3M, from <a href="https://ui.adsabs.harvard.edu/abs/2011PASP..123..423G/abstract">Grav+2011</a>. This catalogue contains a variety of objects including
                        near-Earth objects, main belt asteroids, Jupiter Trojans and comets. It isn't limited by what we can/have observed and is intended to approximate the distribution of all solar
                        system objects.
                    </p>
                    <p>
                        For the real data, we use the Minor Planet Center's Orbit Database (<a href="https://minorplanetcenter.net/iau/MPCORB.html">MPCORB</a>), which contains the details for every
                        small solar system object that has been detected to date. This catalogue is updated frequently as new objects are detected.
                    </p>
                    <p>
                        The idea is that we can merge these two catalogues by replacing synthetic solar objects with real analogues. The difficult part of this is finding "similar" objects between the
                        two catalogues. We can't simply randomly replace synthetic objects with real ones since we don't want to change the underlying distributions in the simulated catalogue. This
                        means we have to be a little smarter about how we merge them.
                    </p>
                    <h3 id="method_details">How does the algorithm work in practice?</h3>
                    <p>
                        As we said above, the key is to replace <i>similar</i> objects. We use 7 parameters to define similarity between objects: position ($x, y, z$), velocity ($v_x, v_y, v_z$) and
                        absolute magnitude ($H$, sort of a proxy for size). To start, we separate the catalogues into bins of absolute magnitude and then for each real object in that bin:
                    </p>

                    <figure>
                        <div class="img-fluid-limited float-start position-relative me-2" style="max-width: min(350px, 100%)">
                            <img src="../../img/hybrid_sso_catalogue/hybrid_methods.gif" class="img-fluid" style="border-radius: 2rem" />
                        </div>
                    </figure>
                    <ul class="list-group list-group-flush list-group-numbered mb-3">
                        <li class="list-group-item">Find the nearest 100 simulated objects (in terms of position) to the real object that are within 0.1 AU</li>
                        <li class="list-group-item">Select the subset of those nearest objects that have not already been assigned</li>
                        <li class="list-group-item">
                            If no objects remain, inject the real object directly into the hybrid catalogue, otherwise assign the object with the closest velocity to be replaced by this real object
                        </li>
                    </ul>
                    <p>
                        The reason that this is tricky is the "that have no already been assigned part" - which means that you can't do this operation efficiently in parallel since each result depends
                        on the earlier results. We speed this up by using a
                        <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.html#scipy.spatial.cKDTree">K-D Tree</a> to find the nearest objects.
                    </p>
                    <p>
                        I've made an example of how this might work in just two dimensions (instead of 7) in a small animation. You can see that for each real objects (blue circle), we identify the
                        closest simulated object (green diamond). For the fourth real object it becomes more difficult, since the closest simulated object has already assigned and so we must choose
                        the second closest simulated object. Finally, for the fifth real object, it is so far from any of the simulated objects that we do not perform a replacement but instead inject
                        it directly into the hybrid catalogue.
                    </p>
                    <h2>Assessing how well we combined the catalogues</h2>
                    <p>
                        So, hundreds of millions of objects and several hours on the computing cluster later, we have our hybrid catalogue! Now the question is how well we did at combining the
                        catalogues intelligently to keep the underlying distributions unchanged.
                    </p>
                </div>
            </div>
        </div>
        <div class="header" style="background-image: url('../../img/hybrid_sso_catalogue/asteroid_belt.jpg">
            <div class="source">
                Image Source:
                <a class="link-light" href="https://www.wired.com/wp-content/uploads/2022/06/Asteroid-Belt-Up-Against-It-Culture-460713865.jpg">SCIEPRO - Wired.com</a>
            </div>
        </div>
    </body>
</html>
